---
layout: post
title: "MSA - 정리중"
---

분산형 거버넌트를 통한 기능별 독립 서비스  
> 하나의 바이너리 -> 기능 별 바이너리  
> 대단히 빠른 개발 속도  
> 기능 별 다른 언어 / 기술 사용  
> 기능 별 디비 사용

시스템이나 팀 구조가 적으면 힘들다.   
시스템이 큰데 빠르게 개발해야 할 때 좋고, 프로덕트 별 지속적인 enhancement 할 수 있어야 한다.  
SI 처럼 치고 빠지긴 힘들다.  

Conway's LAW
>아키텍쳐는 팀의 구조를 따라간다.  
>기술적인 설계보다는 팀에 맞는 설계가 필요하다.  

MSA는 결국 DEVOPS 가 필요하다.   
개발과 운영의 커뮤니케이션이 끊기면 돌아갈 수가 없다.  
개발자는 클라우드를 쉽게 다루지만 기존 SE 들은 어떻게 하지?  
>개발자가 개발한 내용만 쉽게 올릴 수 있게 인프라를 자동화 구성해주자.  

자동화가 끝나면 개발자에게 맡기고 빠지자.  
근데 자동화가 너무 복잡하고 어려운데 어떻게 하지?
> VM 을 사용하자

VM 사용다 보니 이거 너무 무거운데? 
> 컨테이너의 등장

써보니 괜찮네, 근데 컨테이너를 여러 머신에 배포하다 보니 각 머신별로 맞춰서 컨테이너를 배분하는 공수가 너무 큰데?
> 오케스트레이션 Tools 들 의 등장 -> k8s

이제 운영 좀 할만한 듯 하더니 특정 서비스에 문제가 생기면 행이 걸리네?
> Circuit breaker
> 정상 : Req -> A -> B -> Res 일때  
> B 의 장애로 A 까지 행걸리지 않도록 A와 B 사이에 proxy 삽입     
> B가 장애 시 proxy 에서 연결을 바로 끊음  
> 장애 : Req -> A -> Res 의 빠른 응답을 주는 아키텍쳐  
> ex) Netflix 의 Hystrix, Zuul …

좋긴 한데 구조가 너무 어렵잖아..
> 스프링이 라이브러리로 제공!

자바만 되잖아...
> Envoy 등장 ( L7 layer proxy )  
> 서비스간 통신 시 중간에서 타임아웃, 로깅 등 지원

이제 파드에 Envoy 컨테이너만 추가하면 되겠다. -> 수 많은 컨피그 수정 공수 발생
> Istio 등장 
> Proxy A -> Pilot , Istio Auth -> Proxy A -> Proxy B -> Mixer -> Proxy B -> Proxy A   
> Pilot 이 A 에게 B 알려주는 것 = Service Discovery  
> Mixer 에 A,B 간 통신하며 남은 정보 로깅 (용량, 상태 등등 )

